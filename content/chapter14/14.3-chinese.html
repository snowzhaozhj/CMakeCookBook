<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>14.3 使用AddressSanifier向CDash报告内存缺陷 - CMakeCookBook</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../content/preface/preface-chinese.html"><strong aria-hidden="true">2.</strong> 前言</a></li><li class="chapter-item expanded "><a href="../../content/chapter0/0.0-chinese.html"><strong aria-hidden="true">3.</strong> 第0章 配置环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter0/0.1-chinese.html"><strong aria-hidden="true">3.1.</strong> 0.1 获取代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter0/0.2-chinese.html"><strong aria-hidden="true">3.2.</strong> 0.2 Docker镜像</a></li><li class="chapter-item expanded "><a href="../../content/chapter0/0.3-chinese.html"><strong aria-hidden="true">3.3.</strong> 0.3 安装必要的软件</a></li><li class="chapter-item expanded "><a href="../../content/chapter0/0.4-chinese.html"><strong aria-hidden="true">3.4.</strong> 0.4 测试环境</a></li><li class="chapter-item expanded "><a href="../../content/chapter0/0.5-chinese.html"><strong aria-hidden="true">3.5.</strong> 0.5 上报问题并提出改进建议</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.0-chinese.html"><strong aria-hidden="true">4.</strong> 第1章 从可执行文件到库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter1/1.1-chinese.html"><strong aria-hidden="true">4.1.</strong> 1.1 将单个源文件编译为可执行文件</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.2-chinese.html"><strong aria-hidden="true">4.2.</strong> 1.2 切换生成器</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.3-chinese.html"><strong aria-hidden="true">4.3.</strong> 1.3 构建和链接静态库和动态库</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.4-chinese.html"><strong aria-hidden="true">4.4.</strong> 1.4 用条件句控制编译</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.5-chinese.html"><strong aria-hidden="true">4.5.</strong> 1.5 向用户显示选项</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.6-chinese.html"><strong aria-hidden="true">4.6.</strong> 1.6 指定编译器</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.7-chinese.html"><strong aria-hidden="true">4.7.</strong> 1.7 切换构建类型</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.8-chinese.html"><strong aria-hidden="true">4.8.</strong> 1.8 设置编译器选项</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.9-chinese.html"><strong aria-hidden="true">4.9.</strong> 1.9 为语言设定标准</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.10-chinese.html"><strong aria-hidden="true">4.10.</strong> 1.10 使用控制流</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.0-chinese.html"><strong aria-hidden="true">5.</strong> 第2章 检测环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter2/2.1-chinese.html"><strong aria-hidden="true">5.1.</strong> 2.1 检测操作系统</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.2-chinese.html"><strong aria-hidden="true">5.2.</strong> 2.2 处理与平台相关的源代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.3-chinese.html"><strong aria-hidden="true">5.3.</strong> 2.3 处理与编译器相关的源代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.4-chinese.html"><strong aria-hidden="true">5.4.</strong> 2.4 检测处理器体系结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.5-chinese.html"><strong aria-hidden="true">5.5.</strong> 2.5 检测处理器指令集</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.6-chinese.html"><strong aria-hidden="true">5.6.</strong> 2.6 为Eigen库使能向量化</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.0-chinese.html"><strong aria-hidden="true">6.</strong> 第3章 检测外部库和程序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter3/3.1-chinese.html"><strong aria-hidden="true">6.1.</strong> 3.1 检测Python解释器</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.2-chinese.html"><strong aria-hidden="true">6.2.</strong> 3.2 检测Python库</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.3-chinese.html"><strong aria-hidden="true">6.3.</strong> 3.3 检测Python模块和包</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.4-chinese.html"><strong aria-hidden="true">6.4.</strong> 3.4 检测BLAS和LAPACK数学库</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.5-chinese.html"><strong aria-hidden="true">6.5.</strong> 3.5 检测OpenMP的并行环境</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.6-chinese.html"><strong aria-hidden="true">6.6.</strong> 3.6 检测MPI的并行环境</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.7-chinese.html"><strong aria-hidden="true">6.7.</strong> 3.7 检测Eigen库</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.8-chinese.html"><strong aria-hidden="true">6.8.</strong> 3.8 检测Boost库</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.9-chinese.html"><strong aria-hidden="true">6.9.</strong> 3.9 检测外部库:Ⅰ. 使用pkg-config</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.10-chinese.html"><strong aria-hidden="true">6.10.</strong> 3.10 检测外部库:Ⅱ. 自定义find模块</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.0-chinese.html"><strong aria-hidden="true">7.</strong> 第4章 创建和运行测试</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter4/4.1-chinese.html"><strong aria-hidden="true">7.1.</strong> 4.1 创建一个简单的单元测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.2-chinese.html"><strong aria-hidden="true">7.2.</strong> 4.2 使用Catch2库进行单元测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.3-chinese.html"><strong aria-hidden="true">7.3.</strong> 4.3 使用Google Test库进行单元测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.4-chinese.html"><strong aria-hidden="true">7.4.</strong> 4.4 使用Boost Test进行单元测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.5-chinese.html"><strong aria-hidden="true">7.5.</strong> 4.5 使用动态分析来检测内存缺陷</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.6-chinese.html"><strong aria-hidden="true">7.6.</strong> 4.6 预期测试失败</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.7-chinese.html"><strong aria-hidden="true">7.7.</strong> 4.7 使用超时测试运行时间过长的测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.8-chinese.html"><strong aria-hidden="true">7.8.</strong> 4.8 并行测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.9-chinese.html"><strong aria-hidden="true">7.9.</strong> 4.9 运行测试子集</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.10-chinese.html"><strong aria-hidden="true">7.10.</strong> 4.10 使用测试固件</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.0-chinese.html"><strong aria-hidden="true">8.</strong> 第5章 配置时和构建时的操作</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter5/5.1-chinese.html"><strong aria-hidden="true">8.1.</strong> 5.1 使用平台无关的文件操作</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.2-chinese.html"><strong aria-hidden="true">8.2.</strong> 5.2 配置时运行自定义命令</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.3-chinese.html"><strong aria-hidden="true">8.3.</strong> 5.3 构建时运行自定义命令:Ⅰ. 使用add_custom_command</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.4-chinese.html"><strong aria-hidden="true">8.4.</strong> 5.4 构建时运行自定义命令:Ⅱ. 使用add_custom_target</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.5-chinese.html"><strong aria-hidden="true">8.5.</strong> 5.5 构建时为特定目标运行自定义命令</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.6-chinese.html"><strong aria-hidden="true">8.6.</strong> 5.6 探究编译和链接命令</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.7-chinese.html"><strong aria-hidden="true">8.7.</strong> 5.7 探究编译器标志命令</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.8-chinese.html"><strong aria-hidden="true">8.8.</strong> 5.8 探究可执行命令</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.9-chinese.html"><strong aria-hidden="true">8.9.</strong> 5.9 使用生成器表达式微调配置和编译</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.0-chinese.html"><strong aria-hidden="true">9.</strong> 第6章 生成源码</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter6/6.1-chinese.html"><strong aria-hidden="true">9.1.</strong> 6.1 配置时生成源码</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.2-chinese.html"><strong aria-hidden="true">9.2.</strong> 6.2 使用Python在配置时生成源码</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.3-chinese.html"><strong aria-hidden="true">9.3.</strong> 6.3 构建时使用Python生成源码</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.4-chinese.html"><strong aria-hidden="true">9.4.</strong> 6.4 记录项目版本信息以便报告</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.5-chinese.html"><strong aria-hidden="true">9.5.</strong> 6.5 从文件中记录项目版本</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.6-chinese.html"><strong aria-hidden="true">9.6.</strong> 6.6 配置时记录Git Hash值</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.7-chinese.html"><strong aria-hidden="true">9.7.</strong> 6.7 构建时记录Git Hash值</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.0-chinese.html"><strong aria-hidden="true">10.</strong> 第7章 构建项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter7/7.1-chinese.html"><strong aria-hidden="true">10.1.</strong> 7.1 使用函数和宏重用代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.2-chinese.html"><strong aria-hidden="true">10.2.</strong> 7.2 将CMake源代码分成模块</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.3-chinese.html"><strong aria-hidden="true">10.3.</strong> 7.3 编写函数来测试和设置编译器标志</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.4-chinese.html"><strong aria-hidden="true">10.4.</strong> 7.4 用指定参数定义函数或宏</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.5-chinese.html"><strong aria-hidden="true">10.5.</strong> 7.5 重新定义函数和宏</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.6-chinese.html"><strong aria-hidden="true">10.6.</strong> 7.6 使用废弃函数、宏和变量</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.7-chinese.html"><strong aria-hidden="true">10.7.</strong> 7.7 add_subdirectory的限定范围</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.8-chinese.html"><strong aria-hidden="true">10.8.</strong> 7.8 使用target_sources避免全局变量</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.9-chinese.html"><strong aria-hidden="true">10.9.</strong> 7.9 组织Fortran项目</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.0-chinese.html"><strong aria-hidden="true">11.</strong> 第8章 超级构建模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter8/8.1-chinese.html"><strong aria-hidden="true">11.1.</strong> 8.1 使用超级构建模式</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.2-chinese.html"><strong aria-hidden="true">11.2.</strong> 8.2 使用超级构建管理依赖项:Ⅰ.Boost库</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.3-chinese.html"><strong aria-hidden="true">11.3.</strong> 8.3 使用超级构建管理依赖项:Ⅱ.FFTW库</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.4-chinese.html"><strong aria-hidden="true">11.4.</strong> 8.4 使用超级构建管理依赖项:Ⅲ.Google Test框架</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.5-chinese.html"><strong aria-hidden="true">11.5.</strong> 8.5 使用超级构建支持项目</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.0-chinese.html"><strong aria-hidden="true">12.</strong> 第9章 语言混合项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter9/9.1-chinese.html"><strong aria-hidden="true">12.1.</strong> 9.1 使用C/C++库构建Fortran项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.2-chinese.html"><strong aria-hidden="true">12.2.</strong> 9.2 使用Fortran库构建C/C++项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.3-chinese.html"><strong aria-hidden="true">12.3.</strong> 9.3 使用Cython构建C++和Python项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.4-chinese.html"><strong aria-hidden="true">12.4.</strong> 9.4 使用Boost.Python构建C++和Python项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.5-chinese.html"><strong aria-hidden="true">12.5.</strong> 9.5 使用pybind11构建C++和Python项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.6-chinese.html"><strong aria-hidden="true">12.6.</strong> 9.6 使用Python CFFI混合C，C++，Fortran和Python</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.0-chinese.html"><strong aria-hidden="true">13.</strong> 第10章 编写安装程序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter10/10.1-chinese.html"><strong aria-hidden="true">13.1.</strong> 10.1 安装项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.2-chinese.html"><strong aria-hidden="true">13.2.</strong> 10.2 生成输出头文件</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.3-chinese.html"><strong aria-hidden="true">13.3.</strong> 10.3 输出目标</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.4-chinese.html"><strong aria-hidden="true">13.4.</strong> 10.4 安装超级构建</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.0-chinese.html"><strong aria-hidden="true">14.</strong> 第11章 打包项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter11/11.1-chinese.html"><strong aria-hidden="true">14.1.</strong> 11.1 生成源代码和二进制包</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.2-chinese.html"><strong aria-hidden="true">14.2.</strong> 11.2 通过PyPI发布使用CMake/pybind11构建的C++/Python项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.3-chinese.html"><strong aria-hidden="true">14.3.</strong> 11.3 通过PyPI发布使用CMake/CFFI构建C/Fortran/Python项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.4-chinese.html"><strong aria-hidden="true">14.4.</strong> 11.4 以Conda包的形式发布一个简单的项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.5-chinese.html"><strong aria-hidden="true">14.5.</strong> 11.5 将Conda包作为依赖项发布给项目</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter12/12.0-chinese.html"><strong aria-hidden="true">15.</strong> 第12章 构建文档</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter12/12.1-chinese.html"><strong aria-hidden="true">15.1.</strong> 12.1 使用Doxygen构建文档</a></li><li class="chapter-item expanded "><a href="../../content/chapter12/12.2-chinese.html"><strong aria-hidden="true">15.2.</strong> 12.2 使用Sphinx构建文档</a></li><li class="chapter-item expanded "><a href="../../content/chapter12/12.3-chinese.html"><strong aria-hidden="true">15.3.</strong> 12.3 结合Doxygen和Sphinx</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter13/13.0-chinese.html"><strong aria-hidden="true">16.</strong> 第13章 选择生成器和交叉编译</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter13/13.1-chinese.html"><strong aria-hidden="true">16.1.</strong> 13.1 使用CMake构建Visual Studio 2017项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter13/13.2-chinese.html"><strong aria-hidden="true">16.2.</strong> 13.2 交叉编译hello world示例</a></li><li class="chapter-item expanded "><a href="../../content/chapter13/13.3-chinese.html"><strong aria-hidden="true">16.3.</strong> 13.3 使用OpenMP并行化交叉编译Windows二进制文件</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter14/14.0-chinese.html"><strong aria-hidden="true">17.</strong> 第14章 测试面板</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter14/14.1-chinese.html"><strong aria-hidden="true">17.1.</strong> 14.1 将测试部署到CDash</a></li><li class="chapter-item expanded "><a href="../../content/chapter14/14.2-chinese.html"><strong aria-hidden="true">17.2.</strong> 14.2 CDash显示测试覆盖率</a></li><li class="chapter-item expanded "><a href="../../content/chapter14/14.3-chinese.html" class="active"><strong aria-hidden="true">17.3.</strong> 14.3 使用AddressSanifier向CDash报告内存缺陷</a></li><li class="chapter-item expanded "><a href="../../content/chapter14/14.4-chinese.html"><strong aria-hidden="true">17.4.</strong> 14.4 使用ThreadSaniiser向CDash报告数据争用</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.0-chinese.html"><strong aria-hidden="true">18.</strong> 第15章 使用CMake构建已有项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter15/15.1-chinese.html"><strong aria-hidden="true">18.1.</strong> 15.1 如何开始迁移项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.2-chinese.html"><strong aria-hidden="true">18.2.</strong> 15.2 生成文件并编写平台检查</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.3-chinese.html"><strong aria-hidden="true">18.3.</strong> 15.3 检测所需的链接和依赖关系</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.4-chinese.html"><strong aria-hidden="true">18.4.</strong> 15.4 复制编译标志</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.5-chinese.html"><strong aria-hidden="true">18.5.</strong> 15.5 移植测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.6-chinese.html"><strong aria-hidden="true">18.6.</strong> 15.6 移植安装目标</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.7-chinese.html"><strong aria-hidden="true">18.7.</strong> 15.7 进一步迁移的措施</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.8-chinese.html"><strong aria-hidden="true">18.8.</strong> 15.8 项目转换为CMake的常见问题</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter16/16.0-chinese.html"><strong aria-hidden="true">19.</strong> 第16章 可能感兴趣的书</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter16/16.1-chinese.html"><strong aria-hidden="true">19.1.</strong> 16.1 留下评论——让其他读者知道你的想法</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">CMakeCookBook</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="143-使用addresssanifier向cdash报告内存缺陷"><a class="header" href="#143-使用addresssanifier向cdash报告内存缺陷">14.3 使用AddressSanifier向CDash报告内存缺陷</a></h1>
<p><strong>NOTE</strong>:<em>此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03 中找到，其中包含一个C++示例和一个Fortran例子。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>AddressSanitizer(ASan)是可用于C++、C和Fortran的内存检测。它可以发现内存缺陷，比如：在空闲后使用、返回后使用、作用域后使用、缓冲区溢出、初始化顺序错误和内存泄漏(请参见  https://github.com/google/sanitizers/wiki/AddressSanitizer )。从3.1版本开始，AddressSanitizer是LLVM的一部分；从4.8版本开始，作为GCC的一部分。在这个示例中，我们将在代码中加入两个bug，正常的测试中可能无法检测到。为了检测这些bug，我们将使用AddressSanitizer工具，并将CTest与动态分析结合起来，从而将缺陷报告给CDash。</p>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<p>这个例子中，我们将使用两个源文件和两个测试集：</p>
<pre><code class="language-shell">.
├── CMakeLists.txt
├── CTestConfig.cmake
├── dashboard.cmake
├── src
│    ├── buggy.cpp
│    ├── buggy.hpp
│    └── CMakeLists.txt
└── tests
    ├── CMakeLists.txt
    ├── leaky.cpp
    └── use_after_free.cpp
</code></pre>
<p><code>buggy.cpp</code>包含有两个bug：</p>
<pre><code class="language-c++">#include &quot;buggy.hpp&quot;

#include &lt;iostream&gt;

int function_leaky() {
  double *my_array = new double[1000];
  // do some work ...
  // we forget to deallocate the array
  // delete[] my_array;
  return 0;
}

int function_use_after_free() {
  double *another_array = new double[1000];
  // do some work ...
  // deallocate it, good!
  delete[] another_array;
  // however, we accidentally use the array
  // after it has been deallocated
  std::cout &lt;&lt; &quot;not sure what we get: &quot; &lt;&lt; another_array[123] &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>这些函数在相应的头文件中声明(<code>buggy.hpp</code>）：</p>
<pre><code class="language-c++">#pragma once
int function_leaky();
int function_use_after_free();
</code></pre>
<p>测试文件<code>leaky.cpp</code>中将会验证<code>function_leaky</code>的返回值：</p>
<pre><code class="language-c++">#include &quot;buggy.hpp&quot;
int main() {
  int return_code = function_leaky();
  return return_code;
}
</code></pre>
<p>相应地，<code>use_after_free.cpp</code>会检查<code>function_use_after_free</code>的返回值:</p>
<pre><code class="language-c++">#include &quot;buggy.hpp&quot;
int main() {
  int return_code = function_use_after_free();
  return return_code;
}
</code></pre>
<h2 id="具体实施"><a class="header" href="#具体实施">具体实施</a></h2>
<p>为了使用ASan，我们需要使用特定的标志来编译代码。然后，我们将运行测试并将它们提交到面板。</p>
<ol>
<li>
<p>生成bug库的工作将在<code> src/CMakeLists.txt</code>中完成：</p>
<pre><code class="language-cmake">add_library(buggy &quot;&quot;)

target_sources(buggy
  PRIVATE
  	buggy.cpp
  PUBLIC
  	${CMAKE_CURRENT_LIST_DIR}/buggy.hpp
  )
  
target_include_directories(buggy
  PUBLIC
  	${CMAKE_CURRENT_LIST_DIR}
  )
</code></pre>
</li>
<li>
<p>在文件<code>src/CMakeLists.txt</code>中，我们将添加一个选项用于使用ASan：</p>
<pre><code class="language-cmake">option(ENABLE_ASAN &quot;Enable AddressSanitizer&quot; OFF)

if(ENABLE_ASAN)
  if(CMAKE_CXX_COMPILER_ID MATCHES GNU)
    message(STATUS &quot;AddressSanitizer enabled&quot;)
    target_compile_options(buggy
      PUBLIC
      	-g -O1 -fsanitize=address -fno-omit-frame-pointer
      )
    target_link_libraries(buggy
      PUBLIC
      	asan
      )
  else()
  	message(WARNING &quot;AddressSanitizer not supported for this compiler&quot;)
  endif()
endif()
</code></pre>
</li>
<li>
<p>测试在<code>tests/CMakeLists.txt</code>中定义:</p>
<pre><code class="language-cmake">foreach(_test IN ITEMS leaky use_after_free)
  add_executable(${_test} ${_test}.cpp)
  target_link_libraries(${_test} buggy)
  
  add_test(
    NAME
    	${_test}
    COMMAND
    	$&lt;TARGET_FILE:${_test}&gt;
    )
endforeach()
</code></pre>
</li>
<li>
<p>主<code>CMakeLists.txt</code>与之前的示例基本相同：</p>
<pre><code class="language-cmake"># set minimum cmake version
cmake_minimum_required(VERSION 3.5 FATAL_ERROR)

# project name and language
project(recipe-03 LANGUAGES CXX)

# require C++11
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_EXTENSIONS OFF)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# process src/CMakeLists.txt
add_subdirectory(src)
enable_testing()

# allow to report to a cdash dashboard
include(CTest)

# process tests/CMakeLists.txt
add_subdirectory(tests)
</code></pre>
</li>
<li>
<p><code>CTestConfig.cmake</code>也没有修改：</p>
<pre><code class="language-cmake">set(CTEST_DROP_METHOD &quot;http&quot;)
set(CTEST_DROP_SITE &quot;my.cdash.org&quot;)
set(CTEST_DROP_LOCATION &quot;/submit.php?project=cmake-cookbook&quot;)
set(CTEST_DROP_SITE_CDASH TRUE)
</code></pre>
</li>
<li>
<p>这个示例中，我们使用CTest脚本向CDash提交结果；为此，我们将创建一个文件<code> dashboard.cmake</code>(与主<code>CMakeLists.txt</code>和`` CTestConfig.cmake`位于同一个目录下)：</p>
<pre><code class="language-cmake">set(CTEST_PROJECT_NAME &quot;example&quot;)
cmake_host_system_information(RESULT _site QUERY HOSTNAME)
set(CTEST_SITE ${_site})
set(CTEST_BUILD_NAME &quot;${CMAKE_SYSTEM_NAME}-${CMAKE_HOST_SYSTEM_PROCESSOR}&quot;)

set(CTEST_SOURCE_DIRECTORY &quot;${CTEST_SCRIPT_DIRECTORY}&quot;)
set(CTEST_BINARY_DIRECTORY &quot;${CTEST_SCRIPT_DIRECTORY}/build&quot;)

include(ProcessorCount)
ProcessorCount(N)
if(NOT N EQUAL 0)
  set(CTEST_BUILD_FLAGS -j${N})
  set(ctest_test_args ${ctest_test_args} PARALLEL_LEVEL ${N})
endif()

ctest_start(Experimental)

ctest_configure(
  OPTIONS
  	-DENABLE_ASAN:BOOL=ON
  )

ctest_build()
ctest_test()

set(CTEST_MEMORYCHECK_TYPE &quot;AddressSanitizer&quot;)
ctest_memcheck()

ctest_submit()
</code></pre>
</li>
<li>
<p>我们将执行<code> dashboard.cmake</code>脚本。注意，我们使用<code>CTEST_CMAKE_GENERATOR</code>与生成器选项的方式：</p>
<pre><code class="language-shell">$ ctest -S dashboard.cmake -D 

CTEST_CMAKE_GENERATOR=&quot;Unix Makefiles&quot;
Each . represents 1024 bytes of output
. Size of output: 0K
Each symbol represents 1024 bytes of output.
'!' represents an error and '*' a warning.
. Size of output: 1K
</code></pre>
</li>
<li>
<p>结果将会出现在CDash网站上:</p>
<p><img src="../../images/chapter14/14-6.png" alt="" /></p>
</li>
</ol>
<h2 id="具体实施-1"><a class="header" href="#具体实施-1">具体实施</a></h2>
<p>这个示例中，成功地向仪表板的动态分析部分报告了内存错误。我们可以通过浏览缺陷详细信息，得到进一步的了解:</p>
<p><img src="../../images/chapter14/14-7.png" alt="" /></p>
<p>通过单击各个链接，可以浏览完整信息的输出。</p>
<p>注意，也可以在本地生成AddressSanitizer报告。这个例子中，我们需要设置<code>ENABLE_ASAN</code>:</p>
<pre><code class="language-shell">$ mkdir -p build
$ cd build
$ cmake -DENABLE_ASAN=ON ..
$ cmake --build .
$ cmake --build . --target test

Start 1: leaky
1/2 Test #1: leaky ............................***Failed 0.07 sec
Start 2: use_after_free
2/2 Test #2: use_after_free ...................***Failed 0.04 sec
0% tests passed, 2 tests failed out of 2
</code></pre>
<p>运行<code>leaky</code>测试，直接产生以下结果:</p>
<pre><code class="language-shell">$ ./build/tests/leaky

=================================================================
==18536==ERROR: LeakSanitizer: detected memory leaks
Direct leak of 8000 byte(s) in 1 object(s) allocated from:
#0 0x7ff984da1669 in operator new[](unsigned long) /build/gcc/src/gcc/libsanitizer/asan/asan_new_delete.cc:82
#1 0x564925c93fd2 in function_leaky() /home/user/cmake-recipes/chapter-14/recipe-03/cxx-example/src/buggy.cpp:7
#2 0x564925c93fb2 in main /home/user/cmake-recipes/chapter-14/recipe-03/cxx-example/tests/leaky.cpp:4
#3 0x7ff98403df49 in __libc_start_main (/usr/lib/libc.so.6+0x20f49)
SUMMARY: AddressSanitizer: 8000 byte(s) leaked in 1 allocation(s).
</code></pre>
<p>相应地，我们可以直接运行<code>use_after_free</code>，得到详细的输出:</p>
<pre><code class="language-shell">$ ./build/tests/use_after_free

=================================================================
==18571==ERROR: AddressSanitizer: heap-use-after-free on address 0x6250000004d8 at pc 0x557ffa8b0102 bp 0x7ffe8c560200 sp 0x7ffe8c5601f0
READ of size 8 at 0x6250000004d8 thread T0
#0 0x557ffa8b0101 in function_use_after_free() /home/user/cmake-recipes/chapter-14/recipe-03/cxx-example/src/buggy.cpp:28
#1 0x557ffa8affb2 in main /home/user/cmake-recipes/chapter-14/recipe-03/cxx-example/tests/use_after_free.cpp:4
#2 0x7ff1d6088f49 in __libc_start_main (/usr/lib/libc.so.6+0x20f49)
#3 0x557ffa8afec9 in _start (/home/user/cmake-recipes/chapter-14/recipe-03/cxx-example/build/tests/use_after_free+0xec9)
0x6250000004d8 is located 984 bytes inside of 8000-byte region [0x625000000100,0x625000002040)
freed by thread T0 here:
#0 0x7ff1d6ded5a9 in operator delete[](void*) /build/gcc/src/gcc/libsanitizer/asan/asan_new_delete.cc:128
#1 0x557ffa8afffa in function_use_after_free() /home/user/cmake-recipes/chapter-14/recipe-03/cxx-example/src/buggy.cpp:24
#2 0x557ffa8affb2 in main /home/user/cmake-recipes/chapter-14/recipe-03/cxx-example/tests/use_after_free.cpp:4
#3 0x7ff1d6088f49 in __libc_start_main (/usr/lib/libc.so.6+0x20f49)
previously allocated by thread T0 here:
#0 0x7ff1d6dec669 in operator new[](unsigned long) /build/gcc/src/gcc/libsanitizer/asan/asan_new_delete.cc:82
#1 0x557ffa8affea in function_use_after_free() /home/user/cmake-recipes/chapter-14/recipe-03/cxx-example/src/buggy.cpp:19
#2 0x557ffa8affb2 in main /home/user/cmake-recipes/chapter-14/recipe-03/cxx-example/tests/use_after_free.cpp:4
#3 0x7ff1d6088f49 in __libc_start_main (/usr/lib/libc.so.6+0x20f49)
SUMMARY: AddressSanitizer: heap-use-after-free /home/user/cmake-recipes/chapter-14/recipe-03/cxx-example/src/buggy.cpp:28 in function_use_after_free()
Shadow bytes around the buggy address:
0x0c4a7fff8040: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c4a7fff8050: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c4a7fff8060: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c4a7fff8070: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c4a7fff8080: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
=&gt;0x0c4a7fff8090: fd fd fd fd fd fd fd fd fd fd fd[fd]fd fd fd fd
0x0c4a7fff80a0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c4a7fff80b0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c4a7fff80c0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c4a7fff80d0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c4a7fff80e0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
Shadow byte legend (one shadow byte represents 8 application bytes):
Addressable: 00
Partially addressable: 01 02 03 04 05 06 07
Heap left redzone: fa
Freed heap region: fd
Stack left redzone: f1
Stack mid redzone: f2
Stack right redzone: f3
Stack after return: f5
Stack use after scope: f8
Global redzone: f9
Global init order: f6
Poisoned by user: f7
Container overflow: fc
Array cookie: ac
Intra object redzone: bb
ASan internal: fe
Left alloca redzone: ca
Right alloca redzone: cb
==18571==ABORTING
</code></pre>
<p>如果我们在没有AddressSanitizer的情况下进行测试(默认情况下<code>ENABLE_ASAN</code>是关闭的)，就不会报告错误：</p>
<pre><code class="language-shell">$ mkdir -p build_no_asan
$ cd build_no_asan
$ cmake ..
$ cmake --build .
$ cmake --build . --target test

Start 1: leaky
1/2 Test #1: leaky ............................ Passed 0.00 sec
Start 2: use_after_free
2/2 Test #2: use_after_free ................... Passed 0.00 sec
100% tests passed, 0 tests failed out of 2
</code></pre>
<p>实际上，泄漏只会浪费内存，而<code>use_after_free</code>可能会导致未定义行为。调试这些问题的一种方法是使用valgrind (http://valgrind.org )。</p>
<p>与前两个示例相反，我们使用了CTest脚本来配置、构建和测试代码，并将报告提交到面板。要了解此示例的工作原理，请仔细查看<code> dashboard.cmake</code>脚本。首先，我们定义项目名称并设置主机报告和构建名称:</p>
<pre><code class="language-cmake">set(CTEST_PROJECT_NAME &quot;example&quot;)
cmake_host_system_information(RESULT _site QUERY HOSTNAME)
set(CTEST_SITE ${_site})
set(CTEST_BUILD_NAME &quot;${CMAKE_SYSTEM_NAME}-${CMAKE_HOST_SYSTEM_PROCESSOR}&quot;)
</code></pre>
<p>我们的例子中，<code>CTEST_BUILD_NAME</code>的计算结果是<code>Linux-x86_64</code>。不同的操作系统下，可能会观察到不同的结果。</p>
<p>接下来，我们为源和构建目录指定路径:</p>
<pre><code class="language-cmake">set(CTEST_SOURCE_DIRECTORY &quot;${CTEST_SCRIPT_DIRECTORY}&quot;)
set(CTEST_BINARY_DIRECTORY &quot;${CTEST_SCRIPT_DIRECTORY}/build&quot;)
</code></pre>
<p>我们可以将生成器设置为<code>Unix Makefile</code>:</p>
<pre><code class="language-cmake">set(CTEST_CMAKE_GENERATOR &quot;Unix Makefiles&quot;)
</code></pre>
<p>但是，对于更具可移植性的测试脚本，我们更愿意通过命令行提供生成器:</p>
<pre><code class="language-shell">$ ctest -S dashboard.cmake -D CTEST_CMAKE_GENERATOR=&quot;Unix Makefiles&quot;
</code></pre>
<p><code> dashboard.cmake</code>中的下一个代码片段，将计算出机器上可用的CPU芯数量，并将测试步骤的并行级设置为可用CPU芯数量，以使总测试时间最小化:</p>
<pre><code class="language-cmake">include(ProcessorCount)
ProcessorCount(N)
if(NOT N EQUAL 0)
	set(CTEST_BUILD_FLAGS -j${N})
	set(ctest_test_args ${ctest_test_args} PARALLEL_LEVEL ${N})
endif()
</code></pre>
<p>接下来，我们开始测试步骤并配置代码，将<code>ENABLE_ASAN</code>设置为<code>ON</code>:</p>
<pre><code class="language-cmake">ctest_start(Experimental)

ctest_configure(
  OPTIONS
  	-DENABLE_ASAN:BOOL=ON
  )
</code></pre>
<p><code>dashboard.cmake</code>其他命令为映射到构建、测试、内存检查和提交步骤:</p>
<pre><code class="language-cmake">ctest_build()
ctest_test()

set(CTEST_MEMORYCHECK_TYPE &quot;AddressSanitizer&quot;)

ctest_memcheck()
ctest_submit()
</code></pre>
<h2 id="更多信息"><a class="header" href="#更多信息">更多信息</a></h2>
<p>细心的读者会注意到，在链接目标之前，我们没有在系统上搜索AddressSanitizer。实际中，库查找工作已经提前做完，以避免在链接阶段出现意外。</p>
<p>有关AddressSanitizer文档和示例的更多信息，请参见https://github.com/google/sanitizers/wiki/AddressSanitizer 。AddressSanitizer并不仅限于C和C++。对于Fortran示例，读者可以参考 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03/fortran-example 。</p>
<p><strong>NOTE</strong>:<em>可以在https://github.com/arsenm/sanitizers-cmake 上找到CMake程序，用来查找杀毒程序和调整编译器标志</em></p>
<p>下面的博客文章讨论了如何添加对动态分析工具的支持，对我们很有启发性：https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../content/chapter14/14.2-chinese.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../content/chapter14/14.4-chinese.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../content/chapter14/14.2-chinese.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../content/chapter14/14.4-chinese.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
