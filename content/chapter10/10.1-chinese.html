<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>10.1 安装项目 - CMakeCookBook</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../content/preface/preface-chinese.html"><strong aria-hidden="true">2.</strong> 前言</a></li><li class="chapter-item expanded "><a href="../../content/chapter0/0.0-chinese.html"><strong aria-hidden="true">3.</strong> 第0章 配置环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter0/0.1-chinese.html"><strong aria-hidden="true">3.1.</strong> 0.1 获取代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter0/0.2-chinese.html"><strong aria-hidden="true">3.2.</strong> 0.2 Docker镜像</a></li><li class="chapter-item expanded "><a href="../../content/chapter0/0.3-chinese.html"><strong aria-hidden="true">3.3.</strong> 0.3 安装必要的软件</a></li><li class="chapter-item expanded "><a href="../../content/chapter0/0.4-chinese.html"><strong aria-hidden="true">3.4.</strong> 0.4 测试环境</a></li><li class="chapter-item expanded "><a href="../../content/chapter0/0.5-chinese.html"><strong aria-hidden="true">3.5.</strong> 0.5 上报问题并提出改进建议</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.0-chinese.html"><strong aria-hidden="true">4.</strong> 第1章 从可执行文件到库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter1/1.1-chinese.html"><strong aria-hidden="true">4.1.</strong> 1.1 将单个源文件编译为可执行文件</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.2-chinese.html"><strong aria-hidden="true">4.2.</strong> 1.2 切换生成器</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.3-chinese.html"><strong aria-hidden="true">4.3.</strong> 1.3 构建和链接静态库和动态库</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.4-chinese.html"><strong aria-hidden="true">4.4.</strong> 1.4 用条件句控制编译</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.5-chinese.html"><strong aria-hidden="true">4.5.</strong> 1.5 向用户显示选项</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.6-chinese.html"><strong aria-hidden="true">4.6.</strong> 1.6 指定编译器</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.7-chinese.html"><strong aria-hidden="true">4.7.</strong> 1.7 切换构建类型</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.8-chinese.html"><strong aria-hidden="true">4.8.</strong> 1.8 设置编译器选项</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.9-chinese.html"><strong aria-hidden="true">4.9.</strong> 1.9 为语言设定标准</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.10-chinese.html"><strong aria-hidden="true">4.10.</strong> 1.10 使用控制流</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.0-chinese.html"><strong aria-hidden="true">5.</strong> 第2章 检测环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter2/2.1-chinese.html"><strong aria-hidden="true">5.1.</strong> 2.1 检测操作系统</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.2-chinese.html"><strong aria-hidden="true">5.2.</strong> 2.2 处理与平台相关的源代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.3-chinese.html"><strong aria-hidden="true">5.3.</strong> 2.3 处理与编译器相关的源代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.4-chinese.html"><strong aria-hidden="true">5.4.</strong> 2.4 检测处理器体系结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.5-chinese.html"><strong aria-hidden="true">5.5.</strong> 2.5 检测处理器指令集</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.6-chinese.html"><strong aria-hidden="true">5.6.</strong> 2.6 为Eigen库使能向量化</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.0-chinese.html"><strong aria-hidden="true">6.</strong> 第3章 检测外部库和程序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter3/3.1-chinese.html"><strong aria-hidden="true">6.1.</strong> 3.1 检测Python解释器</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.2-chinese.html"><strong aria-hidden="true">6.2.</strong> 3.2 检测Python库</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.3-chinese.html"><strong aria-hidden="true">6.3.</strong> 3.3 检测Python模块和包</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.4-chinese.html"><strong aria-hidden="true">6.4.</strong> 3.4 检测BLAS和LAPACK数学库</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.5-chinese.html"><strong aria-hidden="true">6.5.</strong> 3.5 检测OpenMP的并行环境</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.6-chinese.html"><strong aria-hidden="true">6.6.</strong> 3.6 检测MPI的并行环境</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.7-chinese.html"><strong aria-hidden="true">6.7.</strong> 3.7 检测Eigen库</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.8-chinese.html"><strong aria-hidden="true">6.8.</strong> 3.8 检测Boost库</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.9-chinese.html"><strong aria-hidden="true">6.9.</strong> 3.9 检测外部库:Ⅰ. 使用pkg-config</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.10-chinese.html"><strong aria-hidden="true">6.10.</strong> 3.10 检测外部库:Ⅱ. 自定义find模块</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.0-chinese.html"><strong aria-hidden="true">7.</strong> 第4章 创建和运行测试</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter4/4.1-chinese.html"><strong aria-hidden="true">7.1.</strong> 4.1 创建一个简单的单元测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.2-chinese.html"><strong aria-hidden="true">7.2.</strong> 4.2 使用Catch2库进行单元测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.3-chinese.html"><strong aria-hidden="true">7.3.</strong> 4.3 使用Google Test库进行单元测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.4-chinese.html"><strong aria-hidden="true">7.4.</strong> 4.4 使用Boost Test进行单元测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.5-chinese.html"><strong aria-hidden="true">7.5.</strong> 4.5 使用动态分析来检测内存缺陷</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.6-chinese.html"><strong aria-hidden="true">7.6.</strong> 4.6 预期测试失败</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.7-chinese.html"><strong aria-hidden="true">7.7.</strong> 4.7 使用超时测试运行时间过长的测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.8-chinese.html"><strong aria-hidden="true">7.8.</strong> 4.8 并行测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.9-chinese.html"><strong aria-hidden="true">7.9.</strong> 4.9 运行测试子集</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.10-chinese.html"><strong aria-hidden="true">7.10.</strong> 4.10 使用测试固件</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.0-chinese.html"><strong aria-hidden="true">8.</strong> 第5章 配置时和构建时的操作</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter5/5.1-chinese.html"><strong aria-hidden="true">8.1.</strong> 5.1 使用平台无关的文件操作</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.2-chinese.html"><strong aria-hidden="true">8.2.</strong> 5.2 配置时运行自定义命令</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.3-chinese.html"><strong aria-hidden="true">8.3.</strong> 5.3 构建时运行自定义命令:Ⅰ. 使用add_custom_command</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.4-chinese.html"><strong aria-hidden="true">8.4.</strong> 5.4 构建时运行自定义命令:Ⅱ. 使用add_custom_target</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.5-chinese.html"><strong aria-hidden="true">8.5.</strong> 5.5 构建时为特定目标运行自定义命令</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.6-chinese.html"><strong aria-hidden="true">8.6.</strong> 5.6 探究编译和链接命令</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.7-chinese.html"><strong aria-hidden="true">8.7.</strong> 5.7 探究编译器标志命令</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.8-chinese.html"><strong aria-hidden="true">8.8.</strong> 5.8 探究可执行命令</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.9-chinese.html"><strong aria-hidden="true">8.9.</strong> 5.9 使用生成器表达式微调配置和编译</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.0-chinese.html"><strong aria-hidden="true">9.</strong> 第6章 生成源码</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter6/6.1-chinese.html"><strong aria-hidden="true">9.1.</strong> 6.1 配置时生成源码</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.2-chinese.html"><strong aria-hidden="true">9.2.</strong> 6.2 使用Python在配置时生成源码</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.3-chinese.html"><strong aria-hidden="true">9.3.</strong> 6.3 构建时使用Python生成源码</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.4-chinese.html"><strong aria-hidden="true">9.4.</strong> 6.4 记录项目版本信息以便报告</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.5-chinese.html"><strong aria-hidden="true">9.5.</strong> 6.5 从文件中记录项目版本</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.6-chinese.html"><strong aria-hidden="true">9.6.</strong> 6.6 配置时记录Git Hash值</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.7-chinese.html"><strong aria-hidden="true">9.7.</strong> 6.7 构建时记录Git Hash值</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.0-chinese.html"><strong aria-hidden="true">10.</strong> 第7章 构建项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter7/7.1-chinese.html"><strong aria-hidden="true">10.1.</strong> 7.1 使用函数和宏重用代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.2-chinese.html"><strong aria-hidden="true">10.2.</strong> 7.2 将CMake源代码分成模块</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.3-chinese.html"><strong aria-hidden="true">10.3.</strong> 7.3 编写函数来测试和设置编译器标志</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.4-chinese.html"><strong aria-hidden="true">10.4.</strong> 7.4 用指定参数定义函数或宏</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.5-chinese.html"><strong aria-hidden="true">10.5.</strong> 7.5 重新定义函数和宏</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.6-chinese.html"><strong aria-hidden="true">10.6.</strong> 7.6 使用废弃函数、宏和变量</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.7-chinese.html"><strong aria-hidden="true">10.7.</strong> 7.7 add_subdirectory的限定范围</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.8-chinese.html"><strong aria-hidden="true">10.8.</strong> 7.8 使用target_sources避免全局变量</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.9-chinese.html"><strong aria-hidden="true">10.9.</strong> 7.9 组织Fortran项目</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.0-chinese.html"><strong aria-hidden="true">11.</strong> 第8章 超级构建模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter8/8.1-chinese.html"><strong aria-hidden="true">11.1.</strong> 8.1 使用超级构建模式</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.2-chinese.html"><strong aria-hidden="true">11.2.</strong> 8.2 使用超级构建管理依赖项:Ⅰ.Boost库</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.3-chinese.html"><strong aria-hidden="true">11.3.</strong> 8.3 使用超级构建管理依赖项:Ⅱ.FFTW库</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.4-chinese.html"><strong aria-hidden="true">11.4.</strong> 8.4 使用超级构建管理依赖项:Ⅲ.Google Test框架</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.5-chinese.html"><strong aria-hidden="true">11.5.</strong> 8.5 使用超级构建支持项目</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.0-chinese.html"><strong aria-hidden="true">12.</strong> 第9章 语言混合项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter9/9.1-chinese.html"><strong aria-hidden="true">12.1.</strong> 9.1 使用C/C++库构建Fortran项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.2-chinese.html"><strong aria-hidden="true">12.2.</strong> 9.2 使用Fortran库构建C/C++项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.3-chinese.html"><strong aria-hidden="true">12.3.</strong> 9.3 使用Cython构建C++和Python项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.4-chinese.html"><strong aria-hidden="true">12.4.</strong> 9.4 使用Boost.Python构建C++和Python项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.5-chinese.html"><strong aria-hidden="true">12.5.</strong> 9.5 使用pybind11构建C++和Python项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.6-chinese.html"><strong aria-hidden="true">12.6.</strong> 9.6 使用Python CFFI混合C，C++，Fortran和Python</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.0-chinese.html"><strong aria-hidden="true">13.</strong> 第10章 编写安装程序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter10/10.1-chinese.html" class="active"><strong aria-hidden="true">13.1.</strong> 10.1 安装项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.2-chinese.html"><strong aria-hidden="true">13.2.</strong> 10.2 生成输出头文件</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.3-chinese.html"><strong aria-hidden="true">13.3.</strong> 10.3 输出目标</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.4-chinese.html"><strong aria-hidden="true">13.4.</strong> 10.4 安装超级构建</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.0-chinese.html"><strong aria-hidden="true">14.</strong> 第11章 打包项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter11/11.1-chinese.html"><strong aria-hidden="true">14.1.</strong> 11.1 生成源代码和二进制包</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.2-chinese.html"><strong aria-hidden="true">14.2.</strong> 11.2 通过PyPI发布使用CMake/pybind11构建的C++/Python项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.3-chinese.html"><strong aria-hidden="true">14.3.</strong> 11.3 通过PyPI发布使用CMake/CFFI构建C/Fortran/Python项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.4-chinese.html"><strong aria-hidden="true">14.4.</strong> 11.4 以Conda包的形式发布一个简单的项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.5-chinese.html"><strong aria-hidden="true">14.5.</strong> 11.5 将Conda包作为依赖项发布给项目</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter12/12.0-chinese.html"><strong aria-hidden="true">15.</strong> 第12章 构建文档</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter12/12.1-chinese.html"><strong aria-hidden="true">15.1.</strong> 12.1 使用Doxygen构建文档</a></li><li class="chapter-item expanded "><a href="../../content/chapter12/12.2-chinese.html"><strong aria-hidden="true">15.2.</strong> 12.2 使用Sphinx构建文档</a></li><li class="chapter-item expanded "><a href="../../content/chapter12/12.3-chinese.html"><strong aria-hidden="true">15.3.</strong> 12.3 结合Doxygen和Sphinx</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter13/13.0-chinese.html"><strong aria-hidden="true">16.</strong> 第13章 选择生成器和交叉编译</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter13/13.1-chinese.html"><strong aria-hidden="true">16.1.</strong> 13.1 使用CMake构建Visual Studio 2017项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter13/13.2-chinese.html"><strong aria-hidden="true">16.2.</strong> 13.2 交叉编译hello world示例</a></li><li class="chapter-item expanded "><a href="../../content/chapter13/13.3-chinese.html"><strong aria-hidden="true">16.3.</strong> 13.3 使用OpenMP并行化交叉编译Windows二进制文件</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter14/14.0-chinese.html"><strong aria-hidden="true">17.</strong> 第14章 测试面板</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter14/14.1-chinese.html"><strong aria-hidden="true">17.1.</strong> 14.1 将测试部署到CDash</a></li><li class="chapter-item expanded "><a href="../../content/chapter14/14.2-chinese.html"><strong aria-hidden="true">17.2.</strong> 14.2 CDash显示测试覆盖率</a></li><li class="chapter-item expanded "><a href="../../content/chapter14/14.3-chinese.html"><strong aria-hidden="true">17.3.</strong> 14.3 使用AddressSanifier向CDash报告内存缺陷</a></li><li class="chapter-item expanded "><a href="../../content/chapter14/14.4-chinese.html"><strong aria-hidden="true">17.4.</strong> 14.4 使用ThreadSaniiser向CDash报告数据争用</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.0-chinese.html"><strong aria-hidden="true">18.</strong> 第15章 使用CMake构建已有项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter15/15.1-chinese.html"><strong aria-hidden="true">18.1.</strong> 15.1 如何开始迁移项目</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.2-chinese.html"><strong aria-hidden="true">18.2.</strong> 15.2 生成文件并编写平台检查</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.3-chinese.html"><strong aria-hidden="true">18.3.</strong> 15.3 检测所需的链接和依赖关系</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.4-chinese.html"><strong aria-hidden="true">18.4.</strong> 15.4 复制编译标志</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.5-chinese.html"><strong aria-hidden="true">18.5.</strong> 15.5 移植测试</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.6-chinese.html"><strong aria-hidden="true">18.6.</strong> 15.6 移植安装目标</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.7-chinese.html"><strong aria-hidden="true">18.7.</strong> 15.7 进一步迁移的措施</a></li><li class="chapter-item expanded "><a href="../../content/chapter15/15.8-chinese.html"><strong aria-hidden="true">18.8.</strong> 15.8 项目转换为CMake的常见问题</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter16/16.0-chinese.html"><strong aria-hidden="true">19.</strong> 第16章 可能感兴趣的书</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter16/16.1-chinese.html"><strong aria-hidden="true">19.1.</strong> 16.1 留下评论——让其他读者知道你的想法</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">CMakeCookBook</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="101-安装项目"><a class="header" href="#101-安装项目">10.1 安装项目</a></h1>
<p><strong>NOTE</strong>:<em>此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-01 中找到，其中有一个C++示例和一个Fortran示例。该示例在CMake 3.6版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>第一个示例中，将介绍我们的小项目和一些基本概念，这些概念也将在后面的示例中使用。安装文件、库和可执行文件是一项非常基础的任务，但是也可能会带来一些缺陷。我们将带您了解这些问题，并展示如何使用CMake有效地避开这些缺陷。</p>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<p>第1章第3节的示例，几乎复用：只添加对UUID库的依赖。这个依赖是有条件的，如果没有找到UUID库，我们将通过预处理程序排除使用UUID库的代码。项目布局如下:</p>
<pre><code class="language-shell">.
├── CMakeLists.txt
├── src
│    ├── CMakeLists.txt
│    ├── hello-world.cpp
│    ├── Message.cpp
│    └── Message.hpp
└── tests
    └── CMakeLists.txt
</code></pre>
<p>我们已经看到，有三个<code>CMakeLists.txt</code>，一个是主<code>CMakeLists.txt</code>，另一个是位于<code>src</code>目录下的，还有一个是位于<code>test</code>目录下的。</p>
<p><code> Message.hpp</code>头文件包含以下内容:</p>
<pre><code class="language-c++">#pragma once

#include &lt;iosfwd&gt;
#include &lt;string&gt;

class Message
{
public:
  Message(const std::string &amp;m) : message_(m) {}
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, Message &amp;obj)
  {
    return obj.printObject(os);
  }

private:
  std::string message_;
  std::ostream &amp;printObject(std::ostream &amp;os);
};

std::string getUUID();
</code></pre>
<p><code>Message.cpp</code>中有相应的实现：</p>
<pre><code class="language-c++">#include &quot;Message.hpp&quot;
#include &lt;iostream&gt;
#include &lt;string&gt;
#ifdef HAVE_UUID
#include &lt;uuid/uuid.h&gt;
#endif
std::ostream &amp;Message::printObject(std::ostream &amp;os)
{
  os &lt;&lt; &quot;This is my very nice message: &quot; &lt;&lt; std::endl;
  os &lt;&lt; message_ &lt;&lt; std::endl;
  os &lt;&lt; &quot;...and here is its UUID: &quot; &lt;&lt; getUUID();
  return os;
}
#ifdef HAVE_UUID
std::string getUUID()
{
  uuid_t uuid;
  uuid_generate(uuid);
  char uuid_str[37];
  uuid_unparse_lower(uuid, uuid_str);
  uuid_clear(uuid);
  std::string uuid_cxx(uuid_str);
  return uuid_cxx;
}
#else
std::string getUUID()
{
  return &quot;Ooooops, no UUID for you!&quot;;
}
#endif
</code></pre>
<p>最后，示例<code>hello-world.cpp</code>内容如下:</p>
<pre><code class="language-c++">#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &quot;Message.hpp&quot;
int main()
{
  Message say_hello(&quot;Hello, CMake World!&quot;);
  std::cout &lt;&lt; say_hello &lt;&lt; std::endl;
  Message say_goodbye(&quot;Goodbye, CMake World&quot;);
  std::cout &lt;&lt; say_goodbye &lt;&lt; std::endl;
  return EXIT_SUCCESS;
}
</code></pre>
<h2 id="具体实施"><a class="header" href="#具体实施">具体实施</a></h2>
<p>我们先来看一下主<code>CMakeLists.txt</code>:</p>
<ol>
<li>
<p>声明CMake最低版本，并定义一个C++11项目。请注意，我们已经为我们的项目设置了一个版本，在<code>project</code>中使用<code>VERSION</code>进行指定:</p>
<pre><code class="language-cmake"># CMake 3.6 needed for IMPORTED_TARGET option
# to pkg_search_module
cmake_minimum_required(VERSION 3.6 FATAL_ERROR)
project(recipe-01
LANGUAGES CXX
VERSION 1.0.0
)
# &lt;&lt;&lt; General set up &gt;&gt;&gt;
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_EXTENSIONS OFF)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
</code></pre>
</li>
<li>
<p>用户可以通过<code>CMAKE_INSTALL_PREFIX</code>变量定义安装目录。CMake会给这个变量设置一个默认值：Windows上的<code>C:\Program Files</code>和Unix上的<code>/usr/local</code>。我们将会打印安装目录的信息：</p>
<pre><code class="language-cmake">message(STATUS &quot;Project will be installed to ${CMAKE_INSTALL_PREFIX}&quot;)
</code></pre>
</li>
<li>
<p>默认情况下，我们更喜欢以Release的方式配置项目。用户可以通过<code>CMAKE_BUILD_TYPE</code>设置此变量，从而改变配置类型，我们将检查是否存在这种情况。如果没有，将设置为默认值:</p>
<pre><code class="language-cmake">if(NOT CMAKE_BUILD_TYPE)
	set(CMAKE_BUILD_TYPE Release CACHE STRING &quot;Build type&quot; FORCE)
endif()
message(STATUS &quot;Build type set to ${CMAKE_BUILD_TYPE}&quot;)
</code></pre>
</li>
<li>
<p>接下来，告诉CMake在何处构建可执行、静态和动态库目标。便于在用户不打算安装项目的情况下，访问这些构建目标。这里使用标准CMake的<code>GNUInstallDirs.cmake</code>模块。这将确保的项目布局的合理性和可移植性：</p>
<pre><code class="language-cmake">include(GNUInstallDirs)

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY
	${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY
	${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY
	${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})
</code></pre>
</li>
<li>
<p>虽然，前面的命令配置了构建目录中输出的位置，但是需要下面的命令来配置可执行程序、库以及安装前缀中包含的文件的位置。它们大致遵循相同的布局，但是我们定义了新的<code>INSTALL_LIBDIR</code>、<code>INSTALL_BINDIR</code>、<code>INSTALL_INCLUDEDIR</code>和<code>INSTALL_CMAKEDIR</code>变量。当然，也可以覆盖这些变量：</p>
<pre><code class="language-cmake"># Offer the user the choice of overriding the installation directories
set(INSTALL_LIBDIR ${CMAKE_INSTALL_LIBDIR} CACHE PATH &quot;Installation directory for libraries&quot;)
set(INSTALL_BINDIR ${CMAKE_INSTALL_BINDIR} CACHE PATH &quot;Installation directory for executables&quot;)
set(INSTALL_INCLUDEDIR ${CMAKE_INSTALL_INCLUDEDIR} CACHE PATH &quot;Installation directory for header files&quot;)
if(WIN32 AND NOT CYGWIN)
	set(DEF_INSTALL_CMAKEDIR CMake)
else()
	set(DEF_INSTALL_CMAKEDIR share/cmake/${PROJECT_NAME})
endif()
set(INSTALL_CMAKEDIR ${DEF_INSTALL_CMAKEDIR} CACHE PATH &quot;Installation directory for CMake files&quot;)
</code></pre>
</li>
<li>
<p>报告组件安装的路径:</p>
<pre><code class="language-cmake"># Report to user
foreach(p LIB BIN INCLUDE CMAKE)
  file(TO_NATIVE_PATH ${CMAKE_INSTALL_PREFIX}/${INSTALL_${p}DIR} _path )
  message(STATUS &quot;Installing ${p} components to ${_path}&quot;)
  unset(_path)
endforeach()
</code></pre>
</li>
<li>
<p>主<code>CMakeLists.txt</code>文件中的最后一个指令添加<code>src</code>子目录，启用测试，并添加<code>tests</code>子目录：</p>
<pre><code class="language-cmake">add_subdirectory(src)
enable_testing()
add_subdirectory(tests)
</code></pre>
</li>
</ol>
<p>现在我们继续分析<code>src/CMakeLists.txt</code>，其定义了构建的实际目标：</p>
<ol>
<li>
<p>我们的项目依赖于UUID库：</p>
<pre><code class="language-cmake"># Search for pkg-config and UUID
find_package(PkgConfig QUIET)
if(PKG_CONFIG_FOUND)
  pkg_search_module(UUID uuid IMPORTED_TARGET)
  if(TARGET PkgConfig::UUID)
    message(STATUS &quot;Found libuuid&quot;)
    set(UUID_FOUND TRUE)
  endif()
endif()
</code></pre>
</li>
<li>
<p>我们希望建立一个动态库，将该目标声明为<code>message-shared </code>:</p>
<pre><code class="language-cmake">add_library(message-shared SHARED &quot;&quot;)
</code></pre>
</li>
<li>
<p>这个目标由<code>target_sources</code>命令指定:</p>
<pre><code class="language-cmake">target_sources(message-shared
  PRIVATE
  	${CMAKE_CURRENT_LIST_DIR}/Message.cpp
  )
</code></pre>
</li>
<li>
<p>我们为目标声明编译时定义和链接库。请注意，所有这些都是<code>PUBLIC</code>，以确保所有依赖的目标将正确继承它们:</p>
<pre><code class="language-cmake">  target_compile_definitions(message-shared
  PUBLIC
  	$&lt;$&lt;BOOL:${UUID_FOUND}&gt;:HAVE_UUID&gt;
  )
target_link_libraries(message-shared
  PUBLIC
  	$&lt;$&lt;BOOL:${UUID_FOUND}&gt;:PkgConfig::UUID&gt;
  )
</code></pre>
</li>
<li>
<p>然后设置目标的附加属性:</p>
<pre><code class="language-cmake">set_target_properties(message-shared
  PROPERTIES
    POSITION_INDEPENDENT_CODE 1
    SOVERSION ${PROJECT_VERSION_MAJOR}
    OUTPUT_NAME &quot;message&quot;
    DEBUG_POSTFIX &quot;_d&quot;
    PUBLIC_HEADER &quot;Message.hpp&quot;
    MACOSX_RPATH ON
    WINDOWS_EXPORT_ALL_SYMBOLS ON
  )
</code></pre>
</li>
<li>
<p>最后，为“Hello, world”程序添加可执行目标:</p>
<pre><code class="language-cmake">add_executable(hello-world_wDSO hello-world.cpp)
</code></pre>
</li>
<li>
<p><code>hello-world_wDSO</code>可执行目标，会链接到动态库：</p>
<pre><code class="language-cmake">target_link_libraries(hello-world_wDSO
  PUBLIC
  	message-shared
  )
</code></pre>
</li>
</ol>
<p><code>src/CMakeLists.txt</code>文件中，还包含安装指令。考虑这些之前，我们需要设置可执行文件的<code>RPATH</code>：</p>
<ol>
<li>
<p>使用CMake路径操作，我们可以设置<code>message_RPATH</code>变量。这将为GNU/Linux和macOS设置适当的<code>RPATH</code>:</p>
<pre><code class="language-cmake">RPATH
file(RELATIVE_PATH _rel ${CMAKE_INSTALL_PREFIX}/${INSTALL_BINDIR} ${CMAKE_INSTALL_PREFIX})
if(APPLE)
	set(_rpath &quot;@loader_path/${_rel}&quot;)
else()
	set(_rpath &quot;\$ORIGIN/${_rel}&quot;)
endif()
file(TO_NATIVE_PATH &quot;${_rpath}/${INSTALL_LIBDIR}&quot; message_RPATH)
</code></pre>
</li>
<li>
<p>现在，可以使用这个变量来设置可执行目标<code>hello-world_wDSO</code>的<code>RPATH</code>(通过目标属性实现)。我们也可以设置额外的属性，稍后会对此进行更多的讨论:</p>
<pre><code class="language-cmake">set_target_properties(hello-world_wDSO
  PROPERTIES
    MACOSX_RPATH ON
    SKIP_BUILD_RPATH OFF
    BUILD_WITH_INSTALL_RPATH OFF
    INSTALL_RPATH &quot;${message_RPATH}&quot;
    INSTALL_RPATH_USE_LINK_PATH ON
  )
</code></pre>
</li>
<li>
<p>终于可以安装库、头文件和可执行文件了！使用CMake提供的<code>install</code>命令来指定安装位置。注意，路径是相对的，我们将在后续进一步讨论这一点:</p>
<pre><code class="language-cmake">install(
  TARGETS
    message-shared
    hello-world_wDSO
  ARCHIVE
    DESTINATION ${INSTALL_LIBDIR}
    COMPONENT lib
  RUNTIME
    DESTINATION ${INSTALL_BINDIR}
    COMPONENT bin
  LIBRARY
    DESTINATION ${INSTALL_LIBDIR}
    COMPONENT lib
  PUBLIC_HEADER
    DESTINATION ${INSTALL_INCLUDEDIR}/message
    COMPONENT dev
  )
</code></pre>
</li>
</ol>
<p><code>tests</code>目录中的<code>CMakeLists.txt</code>文件包含简单的指令，以确保“Hello, World”可执行文件能够正确运行：</p>
<pre><code class="language-cmake">add_test(
  NAME test_shared
  COMMAND $&lt;TARGET_FILE:hello-world_wDSO&gt;
  )
</code></pre>
<p>现在让我们配置、构建和安装项目，并查看结果。添加安装指令时，CMake就会生成一个名为<code>install</code>的新目标，该目标将运行安装规则:</p>
<pre><code class="language-shell">$ mkdir -p build
$ cd build
$ cmake -G&quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=$HOME/Software/recipe-01
$ cmake --build . --target install
</code></pre>
<p>GNU/Linux构建目录的内容如下:</p>
<pre><code class="language-shell">build
├── bin
│    └── hello-world_wDSO
├── CMakeCache.txt
├── CMakeFiles
├── cmake_install.cmake
├── CTestTestfile.cmake
├── install_manifest.txt
├── lib64
│    ├── libmessage.so -&gt; libmessage.so.1
│    └── libmessage.so.1
├── Makefile
├── src
├── Testing
└── tests
</code></pre>
<p>另一方面，在安装位置，可以找到如下的目录结构:</p>
<pre><code class="language-shell">$HOME/Software/recipe-01/
├── bin
│    └── hello-world_wDSO
├── include
│    └── message
│        └── Message.hpp
└── lib64
    ├── libmessage.so -&gt; libmessage.so.1
    └── libmessage.so.1
</code></pre>
<p>这意味着安装指令中给出的位置，是相对于用户给定的<code>CMAKE_INSTALL_PREFIX</code>路径。</p>
<h2 id="工作原理"><a class="header" href="#工作原理">工作原理</a></h2>
<p>这个示例有三个要点我们需要更详细地讨论：</p>
<ul>
<li>使用<code>GNUInstallDirs.cmake</code>定义目标安装的标准位置</li>
<li>在动态库和可执行目标上设置的属性，特别是<code>RPATH</code>的处理</li>
<li>安装指令</li>
</ul>
<p>###安装到标准位置</p>
<p>对于项目的安装来说，什么是好的布局呢？如果只有自己使用该项目，那就无所谓好或坏的布局。然而，一旦向外部发布产品，和他人共用该项目，就应该在安装项目时提供一个合理的布局。幸运的是，我们可以遵循一些标准，CMake可以帮助我们做到这一点。实际上，<code>GNUInstallDirs.cmake </code>模块所做的就是定义这样一组变量，这些变量是安装不同类型文件的子目录的名称。在例子中，使用了以下内容:</p>
<ul>
<li>*<strong>CMAKE_INSTALL_BINDIR</strong>：这将用于定义用户可执行文件所在的子目录，即所选安装目录下的<code>bin</code>目录。</li>
<li><strong>CMAKE_INSTALL_LIBDIR</strong>：这将扩展到目标代码库(即静态库和动态库)所在的子目录。在64位系统上，它是<code>lib64</code>，而在32位系统上，它只是<code>lib</code>。</li>
<li><strong>CMAKE_INSTALL_INCLUDEDIR</strong>：最后，我们使用这个变量为C头文件获取正确的子目录，该变量为<code>include</code>。</li>
</ul>
<p>然而，用户可能希望覆盖这些选项。我们允许在主<code>CMakeLists.txt</code>文件中使用以下方式覆盖选项:</p>
<pre><code class="language-cmake"># Offer the user the choice
of overriding the installation directories
set(INSTALL_LIBDIR ${CMAKE_INSTALL_LIBDIR} CACHE PATH
&quot;Installation directory for libraries&quot;)
set(INSTALL_BINDIR ${CMAKE_INSTALL_BINDIR} CACHE PATH
&quot;Installation directory for executables&quot;)
set(INSTALL_INCLUDEDIR ${CMAKE_INSTALL_INCLUDEDIR} CACHE
PATH &quot;Installation directory for header files&quot;)
</code></pre>
<p>这重新定义了在项目中使用的<code>INSTALL_BINDIR</code>、<code>INSTALL_LIBDIR</code>和<code>INSTALL_INCLUDEDIR</code>变量。我们还定义了<code>INSTALL_CMAKEDIR</code>变量，但它所扮演的角色将在接下来的几个示例中详细讨论。</p>
<p><strong>TIPS</strong>:<em><code>GNUInstallDirs.cmake</code>模块定义了额外的变量，这些变量将有助于，将已安装的文件放置到所选安装前缀的子目录中。请参考CMake在线文档:https://cmake.org/cmake/help/v3.6/module/GNUInstallDirs.html</em></p>
<h3 id="目标属性和rpath处理"><a class="header" href="#目标属性和rpath处理">目标属性和RPATH处理</a></h3>
<p>让我们更仔细地看看在动态库目标上设置的属性，需要设置以下内容:</p>
<ul>
<li><code>POSITION_INDEPENDENT_CODE 1</code>：设置生成位置无关代码所需的编译器标志。有关更多信息，请参考https://en.wikipedia.org/wiki/position-independentent_code</li>
<li><code>SOVERSION ${PROJECT_VERSION_MAJOR}</code> : 这是动态库提供的应用程序编程接口(API)版本。在设置语义版本之后，将其设置为与项目的主版本一致。CMake目标也有一个版本属性，可以用来指定目标的构建版本。注意，<code>SOVERSION</code>和<code>VERSION</code>有所不同：随着时间的推移，提供相同API的多个构建版本。本例中，我们不关心这种的粒度控制：仅使用<code>SOVERSION</code>属性设置API版本就足够了，CMake将为我们将<code>VERSION</code>设置为相同的值。相关详细信息，请参考官方文档:https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html</li>
<li><code>OUTPUT_NAME &quot;message&quot;</code>：这告诉CMake库的名称<code>message</code>，而不是目标<code>message-shared</code>的名称，<code>libmessage.so.1</code>将在构建时生成。从前面给出的构建目录和安装目录的也可以看出，<code> libmessage.so</code>的符号链接也将生成。</li>
<li><code>DEBUG_POSTFIX &quot;_d&quot; </code>：这告诉CMake，如果我们以Debug配置构建项目，则将<code>_d</code>后缀添加到生成的动态库。</li>
<li><code>PUBLIC_HEADER &quot;Message.hpp&quot;</code>：我们使用这个属性来设置头文件列表(本例中只有一个头文件)，声明提供的API函数。这主要用于macOS上的动态库目标，也可以用于其他操作系统和目标。有关详细信息，请参见官方文档:https://cmake.org/cmake/help/v3.6/prop_tgt/PUBLIC_HEADER.html</li>
<li><code>MACOSX_RPATH ON</code>：这将动态库的<code>install_name</code>部分(目录)设置为macOS上的<code>@rpath</code>。</li>
<li><code>WINDOWS_EXPORT_ALL_SYMBOLS ON</code>：这将强制在Windows上编译以导出所有符号。注意，这通常不是一个好的方式，我们将在第2节中展示如何生成导出头文件，以及如何在不同的平台上保证符号的可见性。</li>
</ul>
<p>现在讨论一下<code>RPATH</code>。我们将<code>  hello-world_wDSO</code>可执行文件链接到<code>libmessage.so.1</code>，这意味着在执行时，将加载动态库。因此，有关库位置的信息需要在某个地方进行编码，以便加载程序能够成功地完成其工作。库的定位有两种方法:</p>
<ul>
<li>通过设置环境变量通知链接器:
<ul>
<li>GNU/Linux上，这需要将路径附加到<code>LD_LIBRARY_PATH</code>环境变量中。注意，这很可能会污染系统中所有应用程序的链接器路径，并可能导致符号冲突( https://gms.tf/ld_library_path-considered-harmful.htm )。</li>
<li>macOS上，可以设置<code>DYLD_LIBRARY_PATH</code>变量。这与GNU/Linux上的<code>LD_LIBRARY_PATH</code>有相同的问题，可以通过使用<code>DYLD_FALLBACK_LIBRARY_PATH</code>变量来(部分的)改善这种情况。请看下面的链接，获取相关例子: https://stackoverflow.com/a/3172515/2528668 </li>
</ul>
</li>
<li>可被编码到可执行文件中，使用<code>RPATH</code>可以设置可执行文件的运行时搜索路径</li>
</ul>
<p>后一种方法更健壮。但是，设置动态对象的<code>RPATH</code>时，应该选择哪个路径？我们需要确保可执行文件总是找到正确的动态库，不管它是在构建树中运行还是在安装树中运行。这需要通过设置<code> hello-world_wDSO</code>目标的<code>RPATH</code>相关属性来实现的，通过<code>$ORIGIN</code>(在GNU/Linux上)或<code>@loader_path</code>(在macOS上)变量来查找与可执行文件本身位置相关的路径:</p>
<pre><code class="language-cmake"># Prepare RPATH
file(RELATIVE_PATH _rel ${CMAKE_INSTALL_PREFIX}/${INSTALL_BINDIR} ${CMAKE_INSTALL_PREFIX})
if(APPLE)
	set(_rpath &quot;@loader_path/${_rel}&quot;)
else()
	set(_rpath &quot;\$ORIGIN/${_rel}&quot;)
endif()
file(TO_NATIVE_PATH &quot;${_rpath}/${INSTALL_LIBDIR}&quot; message_RPATH)
</code></pre>
<p>当设置了<code>message_RPATH</code>变量，目标属性将完成剩下的工作:</p>
<pre><code class="language-cmake">set_target_properties(hello-world_wDSO
    PROPERTIES
    MACOSX_RPATH ON
    SKIP_BUILD_RPATH OFF
    BUILD_WITH_INSTALL_RPATH OFF
    INSTALL_RPATH &quot;${message_RPATH}&quot;
    INSTALL_RPATH_USE_LINK_PATH ON
  )
</code></pre>
<p>让我们详细研究一下这个命令：</p>
<ul>
<li><code>SKIP_BUILD_RPATH OFF </code>：告诉CMake生成适当的<code>RPATH</code>，以便能够在构建树中运行可执行文件。</li>
<li><code>UILD_WITH_INSTALL_RPATH OFF</code>：关闭生成可执行目标，使其<code>RPATH</code>调整为与安装树的<code>RPATH</code>相同。在构建树中不运行可执行文件。</li>
<li><code>INSTALL_RPATH &quot;${message_RPATH}&quot; </code>：将已安装的可执行目标的<code>RPATH</code>设置为先前的路径。</li>
<li><code>INSTALL_RPATH_USE_LINK_PATH ON</code>：告诉CMake将链接器搜索路径附加到可执行文件的<code>RPATH</code>中。</li>
</ul>
<p><strong>NOTE</strong>:<em>加载器在Unix系统上如何工作的更多信息，可参见:http://longwei.github.io/rpath_origin/</em></p>
<h3 id="安装指令"><a class="header" href="#安装指令">安装指令</a></h3>
<p>最后，看一下安装指令。我们需要安装一个可执行文件、一个库和一个头文件。可执行文件和库是构建目标，因此我们使用安装命令的<code>TARGETS</code>选项。可以同时设置多个目标的安装规则：CMake知道它们是什么类型的目标，无论其是可执行程序库、动态库，还是静态库:</p>
<pre><code class="language-cmake">install(
  TARGETS
    message-shared
    hello-world_wDSO
</code></pre>
<p>可执行文件将安装在<code>RUNTIME DESTINATION</code>，将其设置为<code>${INSTALL_BINDIR}</code>。动态库安装到<code>LIBRARY_DESTINATION</code>，将其设置为<code>${INSTALL_LIBDIR}</code>。静态库将安装到<code>ARCHIVE DESTINATION</code>，将其设置为<code>${INSTALL_LIBDIR}</code>:</p>
<pre><code class="language-cmake">ARCHIVE
  DESTINATION ${INSTALL_LIBDIR}
  COMPONENT lib
RUNTIME
  DESTINATION ${INSTALL_BINDIR}
  COMPONENT bin
LIBRARY
  DESTINATION ${INSTALL_LIBDIR}
  COMPONENT lib
</code></pre>
<p>注意，这里不仅指定了<code>DESTINATION</code>，还指定了<code>COMPONENT</code>。使用<code> cmake --build . --target install</code>安装命令，所有组件会按预期安装完毕。然而，有时只安装其中一些可用的。这就是<code>COMPONENT</code>关键字帮助我们做的事情。例如，当只要求安装库，我们可以执行以下步骤:</p>
<pre><code class="language-shell">$ cmake -D COMPONENT=lib -P cmake_install.cmake
</code></pre>
<p>自从<code>Message.hpp</code>头文件设置为项目的公共头文件，我们可以使用<code>PUBLIC_HEADER</code>关键字将其与其他目标安装到选择的目的地:<code>${INSTALL_INCLUDEDIR}/message</code>。库用户现在可以包含头文件：<code>#include &lt;message/Message.hpp&gt;</code>，这需要在编译时，使用<code>-I</code>选项将正确的头文件查找路径位置传递给编译器。</p>
<p>安装指令中的各种目标地址会被解释为相对路径，除非使用绝对路径。但是相对于哪里呢？根据不同的安装工具而不同，而CMake可以去计算目标地址的绝对路径。当使用<code>cmake --build . --target install</code>，路径将相对于<code>CMAKE_INSTALL_PREFIX</code>计算。但当使用CPack时，绝对路径将相对于<code>CPACK_PACKAGING_INSTALL_PREFIX</code>计算。CPack的用法将在第11章中介绍。</p>
<p><strong>NOTE</strong>:<em>Unix Makefile和Ninja生成器还提供了另一种机制:<code>DESTDIR</code>。可以在<code>DESTDIR</code>指定的目录下重新定位整个安装树。也就是说，<code>env DESTDIR=/tmp/stage cmake --build . --target install</code>将安装相对于<code>CMAKE_INSTALL_PREFIX</code>和<code>/tmp/stage</code>目录。可以在这里阅读更多信息:https://www.gnu.org/prep/standards/html_node/DESTDIR.html</em></p>
<h2 id="更多信息"><a class="header" href="#更多信息">更多信息</a></h2>
<p>正确设置<code>RPATH</code>可能相当麻烦，但这对于用户来说无法避免。默认情况下，CMake设置可执行程序的<code>RPATH</code>，假设它们将从构建树运行。但是，安装之后<code>RPATH</code>被清除，当用户想要运行<code>hello-world_wDSO</code>时，就会出现问题。使用Linux上的<code>ldd</code>工具，我们可以检查构建树中的<code>hello-world_wDSO</code>可执行文件，运行<code>ldd hello-world_wDSO</code>将得到以下结果:</p>
<pre><code class="language-shell">libmessage.so.1 =&gt; /home/user/cmake-cookbook/chapter-10/recipe-01/cxx-example/build/lib64/libmessage.so.1(0x00007f7a92e44000)
</code></pre>
<p>在安装目录中运行<code>ldd hello-world_wDSO</code>将得到以下结果:</p>
<pre><code class="language-shell">libmessage.so.1 =&gt; Not found
</code></pre>
<p>这显然是不行的。但是，总是硬编码<code>RPATH</code>来指向构建树或安装目录也是错误的：这两个位置中的任何一个都可能被删除，从而导致可执行文件的损坏。这里给出的解决方案为构建树和安装目录中的可执行文件设置了不同的<code>RPATH</code>，因此它总是指向“有意义”的位置；也就是说，尽可能接近可执行文件。在构建树中运行<code>ldd</code>显示相同的输出:</p>
<pre><code class="language-shell">libmessage.so.1 =&gt; /home/roberto/Workspace/robertodr/cmake-
cookbook/chapter-10/recipe-01/cxx-example/build/lib64/libmessage.so.1
(0x00007f7a92e44000)
</code></pre>
<p>另外，在安装目录下，我们得到:</p>
<pre><code class="language-shell">libmessage.so.1 =&gt; /home/roberto/Software/ch10r01/bin/../lib64/libmessage.so.1 (0x00007fbd2a725000)
</code></pre>
<p>我们使用了带有目标参数的CMake安装命令，因为我们需要安装构建目标。而该命令还有另外4个参数:</p>
<ul>
<li><strong>FILES</strong>和<strong>PROGRAMS</strong>，分别用于安装文件或程序。安装后，并设置安装文件适当的权限。对于文件，对所有者具有读和写权限，对组以及其他用户和组具有读权限。对于程序，将授予执行权限。注意，<code>PROGRAMS</code>要与非构建目标的可执行程序一起使用。参见: https://cmake.org/cmake/help/v3.6/command/install.html#installing-files</li>
<li><strong>DIRECTORY</strong>，用于安装目录。当只给出一个目录名时，它通常被理解为相对于当前源目录。可以对目录的安装粒度进行控制。请参考在线文档： https://cmake.org/cmake/help/v3.6/command/install.html#installing-directories</li>
<li><strong>SCRIPT</strong>，可以使用它在CMake脚本中定义自定义安装规则。参见： https://cmake.org/cmake/help/v3.6/command/install.html#custom-installation-logic</li>
<li><strong>EXPORT</strong>，我们将此参数的讨论推迟到第3节，该参数用于导出目标。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../content/chapter10/10.0-chinese.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../content/chapter10/10.2-chinese.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../content/chapter10/10.0-chinese.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../content/chapter10/10.2-chinese.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
